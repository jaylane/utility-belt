using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using HarmonyLib;

namespace UtilityBelt.Lib {
    /// <summary>
    /// Upload the file generated by this to https://www.speedscope.app/ to see flame charts
    /// </summary>
    public class PerfMonitor {
        private Harmony harmony;
        private static List<string> CallStack = new List<string>();
        private static string perfFilePath = @"C:\Games\Decal Plugins\UtilityBelt\perf.txt";

        private class HookState {
            public long StartTime { get; set; }
            public string MethodName { get; set; }

            public HookState(string methodName) {
                MethodName = methodName;
                StartTime = watch.ElapsedTicks;
            }
        }

        public static BindingFlags DefaultBindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;
        private static string _buffer = "";
        private static Stopwatch watch;

        public PerfMonitor() {
        }

        public void HookAll() {
            CallStack.Add("UB");
            watch = new Stopwatch();
            watch.Start();

            harmony = new Harmony("utilitybelt.gitlab.io.perfmonitor");
            HookClass(typeof(UtilityBeltPlugin));
            foreach (Type type in (typeof(UtilityBeltPlugin)).Assembly.GetTypes()) {
                if (type == typeof(PerfMonitor))
                    continue;
                if ((type.FullName.StartsWith("UtilityBelt.Tools") || type.FullName.StartsWith("UtilityBelt.Lib"))) {
                    if (type.FullName.Contains("LandscapeMaps")) {
                        // TODO: LandscapeMaps breaks this... why though
                        continue;
                    }
                    HookClass(type);
                }
            }
        }

        private void HookClass(Type type) {
            // !m.IsSpecialName skips property getter/setter methods
            var methods = type.GetMethods(DefaultBindingFlags).Where(m => !m.IsSpecialName && !m.Name.Contains("<"));

            foreach (var method in methods) {
                MethodInfo preHook = this.GetType().GetMethod("PerfPreHook", BindingFlags.NonPublic | BindingFlags.Static);
                MethodInfo postHook = this.GetType().GetMethod("PerfPostHook", BindingFlags.NonPublic | BindingFlags.Static);

                harmony.Patch(method, new HarmonyMethod(preHook), new HarmonyMethod(postHook));
            }
        }

        private static void PerfPreHook(out HookState __state, MethodInfo __originalMethod) {
            var name = $"{__originalMethod.DeclaringType.Name}::{__originalMethod.Name}";
            __state = new HookState(name);
            CallStack.Add(name);
        }

        private static void PerfPostHook(HookState __state) {
            var elapsed = watch.ElapsedTicks - __state.StartTime;
            _buffer += $"{string.Join(";", CallStack.ToArray())} {elapsed}\n";
            CallStack.RemoveAt(CallStack.Count - 1);
        }

        public void Dispose() {
            if (_buffer.Length > 0)
                File.AppendAllText(perfFilePath, _buffer);
        }
    }
}
